A small change in code significantly reduces memory usage.

Minh-IIT-MBP:Example dminh$ python -m memory_profiler multi_job_test.py 

###########
# AlGDock #
###########
Molecular docking with adaptively scaled alchemical interaction grids

version 0.0.1
in /Users/dminh/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/AlGDock/HREX.py
last modified Tue Jul  1 14:11:08 2014
    
*** Directories ***
{'start': '/Users/dminh/Installers/AlGDock-0.0.1/Example', 'cool': '/Users/dminh/Installers/AlGDock-0.0.1/Example/cool', 'dock': '/Users/dminh/Installers/AlGDock-0.0.1/Example/dock'}

*** Files ***
previous stored in cool directory:
{'inpcrd': {'L': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.trans.inpcrd'}, 'ligand_database': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.db', 'prmtop': {'L': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.prmtop'}, 'forcefield': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/gaff.dat'}
from arguments and defaults:
{'prmtop': {'RL': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/complex.prmtop', 'R': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/receptor.prmtop', 'L': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.prmtop'}, 'vmd': '/Applications/VMD 1.9.1.app/Contents/Resources/VMD.app/Contents/MacOS/VMD', 'grid_force': None, 'dir_cool': '/Users/dminh/Installers/AlGDock-0.0.1/Example/cool', 'frcmodList': None, 'sander': '/Users/dminh/Installers/amber14/bin/sander', 'namd': '/Users/dminh/Installers/NAMD_2.9_Source/MacOSX-x86_64-g++/namd2', 'grids': {'LJa': '/Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJa.dx.gz', 'LJr': '/Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJr.dx.gz', 'ELE': '/Users/dminh/Installers/AlGDock-0.0.1/Example/grids/pbsa.dx.gz'}, 'ligand_database': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.db', 'fixed_atoms': {'RL': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/complex.pdb', 'R': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/receptor.pdb'}, 'forcefield': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/gaff.dat', 'inpcrd': {'RL': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/complex.trans.inpcrd', 'R': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/receptor.trans.inpcrd', 'L': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.trans.inpcrd'}}

to be used:
{'sander': '/Users/dminh/Installers/amber14/bin/sander', 'namd': '/Users/dminh/Installers/NAMD_2.9_Source/MacOSX-x86_64-g++/namd2', 'grids': {'LJa': '/Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJa.dx.gz', 'LJr': '/Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJr.dx.gz', 'ELE': '/Users/dminh/Installers/AlGDock-0.0.1/Example/grids/pbsa.dx.gz'}, 'prmtop': {'RL': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/complex.prmtop', 'R': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/receptor.prmtop', 'L': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.prmtop'}, 'vmd': '/Applications/VMD 1.9.1.app/Contents/Resources/VMD.app/Contents/MacOS/VMD', 'grid_force': None, 'inpcrd': {'RL': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/complex.trans.inpcrd', 'R': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/receptor.trans.inpcrd', 'L': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.trans.inpcrd'}, 'forcefield': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/gaff.dat', 'fixed_atoms': {'RL': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/complex.pdb', 'R': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/receptor.pdb'}, 'dir_cool': '/Users/dminh/Installers/AlGDock-0.0.1/Example/cool', 'ligand_database': '/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.db', 'frcmodList': ['/Users/dminh/Installers/AlGDock-0.0.1/Example/prmtopcrd/ligand.frcmod']}

*** Simulation parameters and constants ***
for cool:
{'protocol': 'Adaptive', 'seeds_per_state': 50, 'steps_per_seed': 100, 'steps_per_sweep': 100, 'keep_intermediate': False, 'min_repX_acc': 0.3, 'sampler': 'NUTS', 'repX_cycles': 3, 'sweeps_per_cycle': 50, 'therm_speed': 1.0}
for dock:
{'protocol': 'Adaptive', 'do_calc_random_dock_stats': False, 'seeds_per_state': 50, 'site': 'Sphere', 'MCMC_moves': 0, 'min_repX_acc': 0.3, 'receptor_NAMD_Gas': array(0.0), 'site_center': array([ 1.80624,  1.80624,  1.80624]), 'site_density': 10.0, 'score': False, 'sampler': 'NUTS', 'keep_intermediate': False, 'therm_speed': 1.5, 'receptor_NAMD_GBSA': array(-9053.10071), 'sweeps_per_cycle': 50, 'rmsd': True, 'steps_per_seed': 100, 'site_direction': None, 'steps_per_sweep': 100, 'repX_cycles': 2, 'site_max_R': 0.01, 'site_max_X': None}

*** Setting up the simulation ***

>>> Initial docking
  sLJr grid loaded from /Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJr.dx.gz in 33.632 s
  LJr grid loaded from /Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJr.dx.gz in 47.323 s
  LJa grid loaded from /Users/dminh/Installers/AlGDock-0.0.1/Example/grids/LJa.dx.gz in 33.773 s
  ELE grid (APBS) loaded from /Users/dminh/Installers/AlGDock-0.0.1/Example/grids/pbsa.dx.gz in 4.086 s
  50 ligand configurations were randomly docked into the binding site using 5 translations and 100 rotations in 2:18.058
  the predicted free energy difference between the first and second docking states is 1.528316 (0.007447)
  raveled energy terms in 0.182 s
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz
  generated 50 configurations (tau_ac=2.023762, dt=0.002500 ps) with progress 0.000035 in 1.588 s
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.665055, dt=0.002031 ps) with progress 0.000092 in 1.425 s
  the estimated replica exchange acceptance rate is 0.626945
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.709604, dt=0.002500 ps) with progress 0.000242 in 1.406 s
  the estimated replica exchange acceptance rate is 0.552945
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.427831, dt=0.002500 ps) with progress 0.000607 in 1.523 s
  the estimated replica exchange acceptance rate is 0.651385
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=0.902279, dt=0.001675 ps) with progress 0.001376 in 1.539 s
  the estimated replica exchange acceptance rate is 0.569089
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.643952, dt=0.002250 ps) with progress 0.002578 in 1.508 s
  the estimated replica exchange acceptance rate is 0.516579
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.767444, dt=0.002257 ps) with progress 0.005384 in 1.502 s
  the estimated replica exchange acceptance rate is 0.448312
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.696093, dt=0.001053 ps) with progress 0.013575 in 1.465 s
  the estimated replica exchange acceptance rate is 0.440153
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.803552, dt=0.001764 ps) with progress 0.025988 in 1.499 s
  the estimated replica exchange acceptance rate is 0.401165
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.535442, dt=0.002242 ps) with progress 0.046993 in 1.454 s
  the estimated replica exchange acceptance rate is 0.403415
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.572171, dt=0.002500 ps) with progress 0.078566 in 1.511 s
  the estimated replica exchange acceptance rate is 0.343317
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.615012, dt=0.001930 ps) with progress 0.127199 in 1.543 s
  the estimated replica exchange acceptance rate is 0.344710
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.596698, dt=0.001990 ps) with progress 0.196508 in 1.431 s
  the estimated replica exchange acceptance rate is 0.555014
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.457018, dt=0.002258 ps) with progress 0.300068 in 2.168 s
  the estimated replica exchange acceptance rate is 0.448684
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.924910, dt=0.001615 ps) with progress 0.437466 in 2.084 s
  the estimated replica exchange acceptance rate is 0.419721
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=2.035098, dt=0.001682 ps) with progress 0.661164 in 2.048 s
  the estimated replica exchange acceptance rate is 0.450851
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.883028, dt=0.001542 ps) with progress 0.781682 in 2.066 s
  the estimated replica exchange acceptance rate is 0.663103
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=2.166413, dt=0.002425 ps) with progress 0.856237 in 2.071 s
  the estimated replica exchange acceptance rate is 0.609315
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.835689, dt=0.001736 ps) with progress 0.923999 in 2.071 s
  the estimated replica exchange acceptance rate is 0.540134
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.741184, dt=0.001608 ps) with progress 0.969346 in 2.031 s
  the estimated replica exchange acceptance rate is 0.687905
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  generated 50 configurations (tau_ac=1.477224, dt=0.002259 ps) with progress 1.000000 in 1.802 s
  the estimated replica exchange acceptance rate is 0.747593
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

  22 states in the docking process sampled in 3:8.325
  wrote to /Users/dminh/Installers/AlGDock-0.0.1/Example/dock/dock_progress.pkl.gz

Elapsed time for initial docking: 3:8.854
Filename: /Users/dminh/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/AlGDock/HREX.py

Line #    Mem usage    Increment   Line Contents
================================================
   926   61.840 MiB    0.000 MiB     @profile
   927                               def initial_dock(self, randomOnly=False):
   928                                 """
   929                                   Docks the ligand into the receptor
   930                                   
   931                                   The first state of docking is sampled by randomly placing configurations 
   932                                   from the high temperature ligand simulation into the binding site.
   933                                   Intermediate thermodynamic states are chosen such that
   934                                   thermodynamic length intervals are approximately constant.
   935                                   Configurations from each state are subsampled to seed the next simulation.
   936                                 """
   937                                 
   938   61.844 MiB    0.004 MiB       if (len(self.dock_protocol)>0) and (self.dock_protocol[-1]['crossed']):
   939                                   return # Initial docking already complete
   940                             
   941   61.844 MiB    0.000 MiB       self._set_lock('dock')
   942   61.844 MiB    0.000 MiB       dock_start_time = time.time()
   943                             
   944   61.844 MiB    0.000 MiB       if self.dock_protocol==[]:
   945                                   # Select samples from the first cooling state and make sure there are enough
   946   61.844 MiB    0.000 MiB         E_MM = []
   947   61.844 MiB    0.000 MiB         confs = []
   948   61.844 MiB    0.000 MiB         for k in range(len(self.cool_Es[0])):
   949   61.844 MiB    0.000 MiB           E_MM += list(self.cool_Es[0][k]['MM'])
   950   61.844 MiB    0.000 MiB           confs += list(self.confs['cool']['samples'][0][k])
   951   61.844 MiB    0.000 MiB         while len(E_MM)<self.params['dock']['seeds_per_state']:
   952                                     self.tee("More samples from high temperature ligand simulation needed")
   953                                     self._replica_exchange('cool')
   954                                     E_MM = []
   955                                     confs = []
   956                                     for k in range(len(self.cool_Es[0])):
   957                                       E_MM += list(self.cool_Es[0][k]['MM'])
   958                                       confs += list(self.confs['cool']['samples'][0][k])
   959                             
   960   61.844 MiB    0.000 MiB         random_dock_inds = np.array(np.linspace(0,len(E_MM), \
   961   61.855 MiB    0.012 MiB           self.params['dock']['seeds_per_state'],endpoint=False),dtype=int)
   962   61.855 MiB    0.000 MiB         cool0_Es_MM = [E_MM[ind]  for ind in random_dock_inds]
   963   61.855 MiB    0.000 MiB         cool0_confs = [confs[ind] for ind in random_dock_inds]
   964                             
   965                                   # Do the random docking
   966   61.855 MiB    0.000 MiB         self.tee("\n>>> Initial docking")
   967                             
   968                                   # Set up the force field with full interaction grids
   969  137.625 MiB   75.770 MiB         self._set_universe_force_field(self.lambda_scalables)
   970                                 
   971  137.625 MiB    0.000 MiB         lambda_o = {'T':T_HIGH, 'MM':True, 'site':True, \
   972  137.625 MiB    0.000 MiB                     'crossed':False, 'a':0.0}
   973  137.625 MiB    0.000 MiB         for scalable in self._scalables:
   974  137.625 MiB    0.000 MiB           lambda_o[scalable] = 0
   975  137.625 MiB    0.000 MiB         self.dock_protocol = [lambda_o]
   976                             
   977                                   # Either loads or generates the random translations and rotations for the first state of docking
   978  137.625 MiB    0.000 MiB         if not (hasattr(self,'_random_trans') and hasattr(self,'_random_rotT')):
   979  137.625 MiB    0.000 MiB           self._max_n_trans = 10000
   980                                     # Default density of points is 50 per nm**3
   981  137.625 MiB    0.000 MiB           self._n_trans = max(min(np.int(np.ceil(self._forceFields['site'].volume*self.params['dock']['site_density'])),self._max_n_trans),5)
   982  137.625 MiB    0.000 MiB           self._random_trans = np.ndarray((self._max_n_trans), dtype=Vector)
   983  137.984 MiB    0.359 MiB           for ind in range(self._max_n_trans):
   984  137.984 MiB    0.000 MiB             self._random_trans[ind] = Vector(self._forceFields['site'].randomPoint())
   985  137.984 MiB    0.000 MiB           self._max_n_rot = 100
   986  137.984 MiB    0.000 MiB           self._n_rot = 100
   987  137.984 MiB    0.000 MiB           self._random_rotT = np.ndarray((self._max_n_rot,3,3))
   988  137.984 MiB    0.000 MiB           for ind in range(self._max_n_rot):
   989  137.984 MiB    0.000 MiB             self._random_rotT[ind,:,:] = np.transpose(random_rotate())
   990                                   else:
   991                                     self._max_n_trans = self._random_trans.shape[0]
   992                                     self._n_rot = self._random_rotT.shape[0]
   993                             
   994                             #      from netCDF4 import Dataset
   995                             #      idock = Dataset('initial_dock.nc','w',format='NETCDF4')
   996                             #      idock.createDimension('n_conf',self.params['dock']['seeds_per_state'])
   997                             #      idock.createDimension('n_rot',self._n_rot)
   998                             #      idock.createDimension('n_trans',self._n_trans)
   999                             
  1000                                   # Get interaction energies.
  1001                                   # Loop over configurations, random rotations, and random translations
  1002  137.984 MiB    0.000 MiB         E = {}
  1003 2426.828 MiB 2288.844 MiB         for term in (['MM','site']+self._scalables):
  1004                                     # MemoryError may happen here
  1005 2045.355 MiB -381.473 MiB           E[term] = np.zeros((self.params['dock']['seeds_per_state'], \
  1006 2426.828 MiB  381.473 MiB             self._max_n_rot,self._max_n_trans))
  1007                                     
  1008                             #idock.createVariable(term,'f8',('n_conf','n_rot','n_trans'))
  1009                             
  1010                             # np.zeros((self.params['dock']['seeds_per_state'], \
  1011                             #  self._max_n_rot,self._max_n_trans))
  1012                             
  1013                                   # TO DO: Optimize this loop
  1014 2426.828 MiB    0.000 MiB         converged = False
  1015 2426.828 MiB    0.000 MiB         n_trans_o = 0
  1016 2426.828 MiB    0.000 MiB         n_trans_n = self._n_trans
  1017 2525.348 MiB   98.520 MiB         while not converged:
  1018 2523.031 MiB   -2.316 MiB           for c in range(self.params['dock']['seeds_per_state']):
  1019 2523.031 MiB    0.000 MiB             E['MM'][c,:,:] = cool0_Es_MM[c]
  1020 2523.031 MiB    0.000 MiB             for i_rot in range(self._n_rot):
  1021 2523.031 MiB    0.000 MiB               conf_rot = Configuration(self.universe,\
  1022 2523.031 MiB    0.000 MiB                 np.dot(cool0_confs[c], self._random_rotT[i_rot,:,:]))
  1023 2523.031 MiB    0.000 MiB               for i_trans in range(n_trans_o, n_trans_n):
  1024 2523.031 MiB    0.000 MiB                 self.universe.setConfiguration(conf_rot)
  1025 2523.031 MiB    0.000 MiB                 self.universe.translateBy(self._random_trans[i_trans])
  1026 2523.031 MiB    0.000 MiB                 eT = self.universe.energyTerms()
  1027 2523.031 MiB    0.000 MiB                 for (key,value) in eT.iteritems():
  1028 2523.031 MiB    0.000 MiB                   E[term_map[key]][c,i_rot,i_trans] += value
  1029 2523.031 MiB    0.000 MiB           E_c = {}
  1030 2524.184 MiB    1.152 MiB           for term in E.keys():
  1031                                       # MemoryError may happen here
  1032 2524.184 MiB    0.000 MiB             E_c[term] = np.ravel(E[term][:,:self._n_rot,:n_trans_n])
  1033 2524.184 MiB    0.000 MiB           (u_kln,N_k) = self._u_kln([E_c],\
  1034 2525.340 MiB    1.156 MiB             [lambda_o,self._next_dock_state(E=E_c, lambda_o=lambda_o)])
  1035 2525.340 MiB    0.000 MiB           du = u_kln[0,1,:] - u_kln[0,0,:]
  1036 2525.340 MiB    0.000 MiB           bootstrap_reps = 50
  1037 2525.340 MiB    0.000 MiB           f_grid0 = np.zeros(bootstrap_reps)
  1038 2525.348 MiB    0.008 MiB           for b in range(bootstrap_reps):
  1039 2525.348 MiB    0.000 MiB             f_grid0[b] = -np.log(np.mean(np.exp(
  1040 2525.348 MiB    0.000 MiB               -du[np.random.randint(0, len(du), len(du))])))
  1041 2525.348 MiB    0.000 MiB           f_grid0_std = f_grid0.std()
  1042 2525.348 MiB    0.000 MiB           converged = f_grid0_std<0.1
  1043 2525.348 MiB    0.000 MiB           if not converged:
  1044                                       self.tee("  with %s translations "%n_trans_n + \
  1045                                                "the predicted free energy difference is %f (%f)"%(\
  1046                                                f_grid0.mean(),f_grid0_std))
  1047                                       if n_trans_n == self._max_n_trans:
  1048                                         break
  1049                                       n_trans_o = n_trans_n
  1050                                       n_trans_n = min(n_trans_n + 25, self._max_n_trans)
  1051                             
  1052 2525.348 MiB    0.000 MiB         if self._n_trans != n_trans_n:
  1053                                     self._n_trans = n_trans_n
  1054                                     
  1055 2525.348 MiB    0.000 MiB         self.tee("  %d ligand configurations "%len(cool0_Es_MM) + \
  1056                                            "were randomly docked into the binding site using "+ \
  1057                                            "%d translations and %d rotations "%(n_trans_n,self._n_rot) + \
  1058 2525.348 MiB    0.000 MiB                  "in " + HMStime(time.time()-dock_start_time))
  1059 2525.348 MiB    0.000 MiB         self.tee("  the predicted free energy difference between the" + \
  1060 2525.348 MiB    0.000 MiB                  " first and second docking states is " + \
  1061 2525.348 MiB    0.000 MiB                  "%f (%f)"%(f_grid0.mean(),f_grid0_std))
  1062                             
  1063 2525.348 MiB    0.000 MiB         ravel_start_time = time.time()
  1064 2525.348 MiB    0.000 MiB         for term in E.keys():
  1065 2143.875 MiB -381.473 MiB           E[term] = np.ravel(E[term][:,:self._n_rot,:self._n_trans])
  1066  236.703 MiB -1907.172 MiB         self.tee("  raveled energy terms in " + \
  1067  236.703 MiB    0.000 MiB           HMStime(time.time()-ravel_start_time))
  1068                             
  1069                             #      idock.close()
  1070                             
  1071  236.703 MiB    0.000 MiB         stats_start_time = time.time()
  1072  236.703 MiB    0.000 MiB         if self.params['dock']['do_calc_random_dock_stats']:
  1073                                     self.calc_random_dock_stats(E)
  1074                                     self.tee("  calculated random dock stats in " + \
  1075                                       HMStime(time.time()-stats_start_time))
  1076                             
  1077  237.648 MiB    0.945 MiB         self._save_progress('dock')
  1078  237.648 MiB    0.000 MiB         if randomOnly:
  1079                                     self._clear_lock('dock')
  1080                                     return
  1081                                 else:
  1082                                   # Continuing from a previous docking instance
  1083                                   self.tee("\n>>> Initial docking, continued")
  1084                                   lambda_o = self.dock_protocol[-1]
  1085                                   confs = self.confs['dock']['samples'][-1][0]
  1086                                   E = self.dock_Es[-1][0]
  1087                             
  1088                                 # Main loop for initial docking:
  1089                                 # choose new thermodynamic variables,
  1090                                 # randomly select seeds,
  1091                                 # simulate
  1092  237.648 MiB    0.000 MiB       rejectStage = 0
  1093  239.746 MiB    2.098 MiB       while (not self.dock_protocol[-1]['crossed']):
  1094                                   # Determine next value of the protocol
  1095  239.742 MiB   -0.004 MiB         lambda_n = self._next_dock_state(E = E, lambda_o = lambda_o, \
  1096  239.742 MiB    0.000 MiB             pow = rejectStage)
  1097  239.742 MiB    0.000 MiB         self.dock_protocol.append(lambda_n)
  1098  239.742 MiB    0.000 MiB         if len(self.dock_protocol)>100:
  1099                                     raise Exception('Too many replicas!')
  1100                             
  1101                                   # Randomly select seeds for new trajectory
  1102  239.742 MiB    0.000 MiB         u_o = self._u_kln([E],[lambda_o])
  1103  239.742 MiB    0.000 MiB         u_n = self._u_kln([E],[lambda_n])
  1104  239.742 MiB    0.000 MiB         w = np.exp(u_o-u_n)
  1105  239.742 MiB    0.000 MiB         seedIndicies = np.random.choice(len(u_o), \
  1106  239.742 MiB    0.000 MiB           size = self.params['dock']['seeds_per_state'], \
  1107  239.742 MiB    0.000 MiB           p=w/sum(w))
  1108                             
  1109  239.742 MiB    0.000 MiB         if len(self.dock_protocol)==2: # Cooling state 0 configurations, randomly oriented
  1110                                     # Use the lowest energy configuration in the first docking state for replica exchange
  1111  238.848 MiB   -0.895 MiB           ind = np.argmin(u_n)
  1112  238.852 MiB    0.004 MiB           (c,i_rot,i_trans) = np.unravel_index(ind, (self.params['dock']['seeds_per_state'], self._n_rot, self._n_trans))
  1113  238.852 MiB    0.000 MiB           repX_conf = np.add(np.dot(cool0_confs[c], self._random_rotT[i_rot,:,:]),\
  1114  238.855 MiB    0.004 MiB                              self._random_trans[i_trans].array)
  1115  238.855 MiB    0.000 MiB           self.confs['dock']['replicas'] = [repX_conf]
  1116  238.855 MiB    0.000 MiB           self.confs['dock']['samples'] = [[repX_conf]]
  1117  238.855 MiB    0.000 MiB           self.dock_Es = [[dict([(key,np.array([val[ind]])) for (key,val) in E.iteritems()])]]
  1118  238.855 MiB    0.000 MiB           seeds = []
  1119  238.895 MiB    0.039 MiB           for ind in seedIndicies:
  1120  238.895 MiB    0.000 MiB             (c,i_rot,i_trans) = np.unravel_index(ind, (self.params['dock']['seeds_per_state'], self._n_rot, self._n_trans))
  1121  238.895 MiB    0.000 MiB             seeds.append(np.add(np.dot(cool0_confs[c], self._random_rotT[i_rot,:,:]), self._random_trans[i_trans].array))
  1122  238.895 MiB    0.000 MiB           confs = None
  1123  238.895 MiB    0.000 MiB           E = {}
  1124                                   else: # Seeds from last state
  1125  239.742 MiB    0.848 MiB           seeds = [confs[ind] for ind in seedIndicies]
  1126  239.742 MiB    0.000 MiB         self.confs['dock']['seeds'] = seeds
  1127                             
  1128                                   # Store old data
  1129  239.742 MiB    0.000 MiB         confs_o = confs
  1130  239.742 MiB    0.000 MiB         E_o = E
  1131                             
  1132                                   # Simulate
  1133  239.742 MiB    0.000 MiB         sim_start_time = time.time()
  1134  239.742 MiB    0.000 MiB         self._set_universe_force_field(lambda_n)
  1135  239.742 MiB    0.000 MiB         (confs, Es_tot, tau_ac) = self._initial_sim_state('dock', seeds, \
  1136  239.742 MiB    0.000 MiB           normalize=False, doMC=True)
  1137                                   
  1138                                   # Store data
  1139  239.742 MiB    0.000 MiB         self.dock_protocol[-1]['delta_t'] = self.delta_t
  1140  239.742 MiB    0.000 MiB         self.dock_protocol[-1]['tau_ac'] = tau_ac
  1141                             
  1142  239.742 MiB    0.000 MiB         self.tee("  generated %d configurations "%len(confs) + \
  1143                                            "(tau_ac=%f, "%self.dock_protocol[-1]['tau_ac'] + \
  1144                                            "dt=%f ps) "%self.dock_protocol[-1]['delta_t'] + \
  1145                                            "with progress %f "%self.dock_protocol[-1]['a'] + \
  1146  239.742 MiB    0.000 MiB                  "in " + HMStime(time.time()-sim_start_time))
  1147                             
  1148                                   # Get state energies
  1149  239.742 MiB    0.000 MiB         E = self._calc_E(confs)
  1150                             
  1151  239.742 MiB    0.000 MiB         if len(self.dock_protocol)>2:
  1152                                     # Estimate the mean replica exchange acceptance rate
  1153                                     # between the previous and new state
  1154  239.742 MiB    0.000 MiB           (u_kln,N_k) = self._u_kln([[E_o],[E]], self.dock_protocol[-2:])
  1155  239.742 MiB    0.000 MiB           N = min(N_k)
  1156  239.742 MiB    0.000 MiB           acc = np.exp(-u_kln[0,1,:N]-u_kln[1,0,:N]+u_kln[0,0,:N]+u_kln[1,1,:N])
  1157  239.742 MiB    0.000 MiB           mean_acc = np.mean(np.minimum(acc,np.ones(acc.shape)))
  1158                                     
  1159  239.742 MiB    0.000 MiB           if (mean_acc<self.params['dock']['min_repX_acc']):
  1160                                       # If the acceptance probability is too low,
  1161                                       # reject the state and restart
  1162                                       self.dock_protocol.pop()
  1163                                       confs = confs_o
  1164                                       E = E_o
  1165                                       rejectStage += 1
  1166                                       self.tee("  rejected new state, as estimated replica exchange acceptance rate of %f is too low"%mean_acc)
  1167  239.742 MiB    0.000 MiB           elif (mean_acc>0.95) and (not lambda_n['crossed']):
  1168                                       # If the acceptance probability is too high,
  1169                                       # reject the previous state and restart
  1170                                       self.confs['dock']['replicas'][-1] = confs[np.argmin(Es_tot)]
  1171                                       self.dock_protocol.pop()
  1172                                       self.dock_protocol[-1] = lambda_n
  1173                                       self.dock_protocol[-1]['delta_t'] = self.delta_t
  1174                                       rejectStage = 0
  1175                                       lambda_o = lambda_n
  1176                                       self.tee("  rejected previous state, as estimated replica exchange acceptance rate of %f is too high"%mean_acc)
  1177                                     else:
  1178                                       # Store data and continue with initialization
  1179  239.742 MiB    0.000 MiB             self.confs['dock']['replicas'].append(confs[np.argmin(Es_tot)])
  1180  239.742 MiB    0.000 MiB             self.confs['dock']['samples'].append([confs])
  1181  239.742 MiB    0.000 MiB             if (not self.params['dock']['keep_intermediate']):
  1182  239.742 MiB    0.000 MiB               self.confs['dock']['samples'][-2] = []
  1183  239.742 MiB    0.000 MiB             self.dock_Es.append([E])
  1184  239.742 MiB    0.000 MiB             self.dock_protocol[-1]['delta_t'] = self.delta_t
  1185  239.742 MiB    0.000 MiB             rejectStage = 0
  1186  239.742 MiB    0.000 MiB             lambda_o = lambda_n
  1187  239.742 MiB    0.000 MiB             self.tee("  the estimated replica exchange acceptance rate is %f"%mean_acc)
  1188                                   else:
  1189                                     # Store data and continue with initialization (first time)
  1190  239.445 MiB   -0.297 MiB           self.confs['dock']['replicas'].append(confs[np.argmin(Es_tot)])
  1191  239.445 MiB    0.000 MiB           self.confs['dock']['samples'].append([confs])
  1192  239.445 MiB    0.000 MiB           self.dock_Es.append([E])
  1193  239.445 MiB    0.000 MiB           self.dock_protocol[-1]['delta_t'] = self.delta_t
  1194  239.445 MiB    0.000 MiB           rejectStage = 0
  1195  239.445 MiB    0.000 MiB           lambda_o = lambda_n
  1196                                   
  1197  239.746 MiB    0.301 MiB         self._save_progress('dock')
  1198  239.746 MiB    0.000 MiB         self.tee("")
  1199                             
  1200  239.746 MiB    0.000 MiB       K = len(self.dock_protocol)
  1201  239.746 MiB    0.000 MiB       self.tee("  %d states in the docking process sampled in %s"%(K,\
  1202  239.746 MiB    0.000 MiB         HMStime(time.time()-dock_start_time)))
  1203                                   
  1204  239.746 MiB    0.000 MiB       self._dock_cycle += 1
  1205  239.746 MiB    0.000 MiB       self._dock_total_cycle += 1
  1206  239.746 MiB    0.000 MiB       self._save_progress('dock')
  1207  239.746 MiB    0.000 MiB       self.tee("\nElapsed time for initial docking: " + \
  1208  239.746 MiB    0.000 MiB         HMStime(time.time()-dock_start_time))
  1209  239.746 MiB    0.000 MiB       self._clear_lock('dock')

Filename: /Users/dminh/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/AlGDock/HREX.py

Line #    Mem usage    Increment   Line Contents
================================================
   926   61.664 MiB    0.000 MiB     @profile
   927                               def initial_dock(self, randomOnly=False):
   928                                 """
   929                                   Docks the ligand into the receptor
   930                                   
   931                                   The first state of docking is sampled by randomly placing configurations 
   932                                   from the high temperature ligand simulation into the binding site.
   933                                   Intermediate thermodynamic states are chosen such that
   934                                   thermodynamic length intervals are approximately constant.
   935                                   Configurations from each state are subsampled to seed the next simulation.
   936                                 """
   937                                 
   938   61.664 MiB    0.000 MiB       if (len(self.dock_protocol)>0) and (self.dock_protocol[-1]['crossed']):
   939                                   return # Initial docking already complete
   940                             
   941   61.664 MiB    0.000 MiB       self._set_lock('dock')
   942   61.664 MiB    0.000 MiB       dock_start_time = time.time()
   943                             
   944   61.664 MiB    0.000 MiB       if self.dock_protocol==[]:
   945                                   # Select samples from the first cooling state and make sure there are enough
   946   61.664 MiB    0.000 MiB         E_MM = []
   947   61.668 MiB    0.004 MiB         confs = []
   948   61.668 MiB    0.000 MiB         for k in range(len(self.cool_Es[0])):
   949   61.668 MiB    0.000 MiB           E_MM += list(self.cool_Es[0][k]['MM'])
   950   61.668 MiB    0.000 MiB           confs += list(self.confs['cool']['samples'][0][k])
   951   61.668 MiB    0.000 MiB         while len(E_MM)<self.params['dock']['seeds_per_state']:
   952                                     self.tee("More samples from high temperature ligand simulation needed")
   953                                     self._replica_exchange('cool')
   954                                     E_MM = []
   955                                     confs = []
   956                                     for k in range(len(self.cool_Es[0])):
   957                                       E_MM += list(self.cool_Es[0][k]['MM'])
   958                                       confs += list(self.confs['cool']['samples'][0][k])
   959                             
   960   61.668 MiB    0.000 MiB         random_dock_inds = np.array(np.linspace(0,len(E_MM), \
   961   61.676 MiB    0.008 MiB           self.params['dock']['seeds_per_state'],endpoint=False),dtype=int)
   962   61.680 MiB    0.004 MiB         cool0_Es_MM = [E_MM[ind]  for ind in random_dock_inds]
   963   61.680 MiB    0.000 MiB         cool0_confs = [confs[ind] for ind in random_dock_inds]
   964                             
   965                                   # Do the random docking
   966   61.680 MiB    0.000 MiB         self.tee("\n>>> Initial docking")
   967                             
   968                                   # Set up the force field with full interaction grids
   969  137.473 MiB   75.793 MiB         self._set_universe_force_field(self.lambda_scalables)
   970                                 
   971  137.473 MiB    0.000 MiB         lambda_o = {'T':T_HIGH, 'MM':True, 'site':True, \
   972  137.473 MiB    0.000 MiB                     'crossed':False, 'a':0.0}
   973  137.473 MiB    0.000 MiB         for scalable in self._scalables:
   974  137.473 MiB    0.000 MiB           lambda_o[scalable] = 0
   975  137.473 MiB    0.000 MiB         self.dock_protocol = [lambda_o]
   976                             
   977                                   # Either loads or generates the random translations and rotations for the first state of docking
   978  137.473 MiB    0.000 MiB         if not (hasattr(self,'_random_trans') and hasattr(self,'_random_rotT')):
   979  137.473 MiB    0.000 MiB           self._max_n_trans = 10000
   980                                     # Default density of points is 50 per nm**3
   981  137.473 MiB    0.000 MiB           self._n_trans = max(min(np.int(np.ceil(self._forceFields['site'].volume*self.params['dock']['site_density'])),self._max_n_trans),5)
   982  137.547 MiB    0.074 MiB           self._random_trans = np.ndarray((self._max_n_trans), dtype=Vector)
   983  137.973 MiB    0.426 MiB           for ind in range(self._max_n_trans):
   984  137.973 MiB    0.000 MiB             self._random_trans[ind] = Vector(self._forceFields['site'].randomPoint())
   985  137.973 MiB    0.000 MiB           self._max_n_rot = 100
   986  137.973 MiB    0.000 MiB           self._n_rot = 100
   987  137.973 MiB    0.000 MiB           self._random_rotT = np.ndarray((self._max_n_rot,3,3))
   988  137.973 MiB    0.000 MiB           for ind in range(self._max_n_rot):
   989  137.973 MiB    0.000 MiB             self._random_rotT[ind,:,:] = np.transpose(random_rotate())
   990                                   else:
   991                                     self._max_n_trans = self._random_trans.shape[0]
   992                                     self._n_rot = self._random_rotT.shape[0]
   993                             
   994                             #      from netCDF4 import Dataset
   995                             #      idock = Dataset('initial_dock.nc','w',format='NETCDF4')
   996                             #      idock.createDimension('n_conf',self.params['dock']['seeds_per_state'])
   997                             #      idock.createDimension('n_rot',self._n_rot)
   998                             #      idock.createDimension('n_trans',self._n_trans)
   999                             
  1000                                   # Get interaction energies.
  1001                                   # Loop over configurations, random rotations, and random translations
  1002  137.973 MiB    0.000 MiB         E = {}
  1003  139.129 MiB    1.156 MiB         for term in (['MM','site']+self._scalables):
  1004                                     # Large array creation may cause MemoryError
  1005  138.938 MiB   -0.191 MiB           E[term] = np.zeros((self.params['dock']['seeds_per_state'], \
  1006  139.129 MiB    0.191 MiB             self._max_n_rot,self._n_trans))
  1007                                     
  1008                             #idock.createVariable(term,'f8',('n_conf','n_rot','n_trans'))
  1009                             
  1010                             # np.zeros((self.params['dock']['seeds_per_state'], \
  1011                             #  self._max_n_rot,self._max_n_trans))
  1012                             
  1013                                   # TO DO: Optimize this loop
  1014  139.129 MiB    0.000 MiB         converged = False
  1015  139.129 MiB    0.000 MiB         n_trans_o = 0
  1016  139.129 MiB    0.000 MiB         n_trans_n = self._n_trans
  1017  236.492 MiB   97.363 MiB         while not converged:
  1018  235.328 MiB   -1.164 MiB           for c in range(self.params['dock']['seeds_per_state']):
  1019  235.328 MiB    0.000 MiB             E['MM'][c,:,:] = cool0_Es_MM[c]
  1020  235.328 MiB    0.000 MiB             for i_rot in range(self._n_rot):
  1021  235.328 MiB    0.000 MiB               conf_rot = Configuration(self.universe,\
  1022  235.328 MiB    0.000 MiB                 np.dot(cool0_confs[c], self._random_rotT[i_rot,:,:]))
  1023  235.328 MiB    0.000 MiB               for i_trans in range(n_trans_o, n_trans_n):
  1024  235.328 MiB    0.000 MiB                 self.universe.setConfiguration(conf_rot)
  1025  235.328 MiB    0.000 MiB                 self.universe.translateBy(self._random_trans[i_trans])
  1026  235.328 MiB    0.000 MiB                 eT = self.universe.energyTerms()
  1027  235.328 MiB    0.000 MiB                 for (key,value) in eT.iteritems():
  1028  235.328 MiB    0.000 MiB                   E[term_map[key]][c,i_rot,i_trans] += value
  1029  235.328 MiB    0.000 MiB           E_c = {}
  1030  235.328 MiB    0.000 MiB           for term in E.keys():
  1031                                       # MemoryError may happen here
  1032  235.328 MiB    0.000 MiB             E_c[term] = np.ravel(E[term][:,:self._n_rot,:n_trans_n])
  1033  235.328 MiB    0.000 MiB           (u_kln,N_k) = self._u_kln([E_c],\
  1034  236.484 MiB    1.156 MiB             [lambda_o,self._next_dock_state(E=E_c, lambda_o=lambda_o)])
  1035  236.484 MiB    0.000 MiB           du = u_kln[0,1,:] - u_kln[0,0,:]
  1036  236.484 MiB    0.000 MiB           bootstrap_reps = 50
  1037  236.484 MiB    0.000 MiB           f_grid0 = np.zeros(bootstrap_reps)
  1038  236.492 MiB    0.008 MiB           for b in range(bootstrap_reps):
  1039  236.492 MiB    0.000 MiB             f_grid0[b] = -np.log(np.mean(np.exp(
  1040  236.492 MiB    0.000 MiB               -du[np.random.randint(0, len(du), len(du))])))
  1041  236.492 MiB    0.000 MiB           f_grid0_std = f_grid0.std()
  1042  236.492 MiB    0.000 MiB           converged = f_grid0_std<0.1
  1043  236.492 MiB    0.000 MiB           if not converged:
  1044                                       self.tee("  with %s translations "%n_trans_n + \
  1045                                                "the predicted free energy difference is %f (%f)"%(\
  1046                                                f_grid0.mean(),f_grid0_std))
  1047                                       if n_trans_n == self._max_n_trans:
  1048                                         break
  1049                                       n_trans_o = n_trans_n
  1050                                       n_trans_n = min(n_trans_n + 25, self._max_n_trans)
  1051                                       for term in (['MM','site']+self._scalables):
  1052                                         # Large array creation may cause MemoryError
  1053                                         E[term] = np.dstack(E[term], \
  1054                                           np.zeros((self.params['dock']['seeds_per_state'], \
  1055                                           self._max_n_rot,25)))
  1056                             
  1057  236.492 MiB    0.000 MiB         if self._n_trans != n_trans_n:
  1058                                     self._n_trans = n_trans_n
  1059                                     
  1060  236.492 MiB    0.000 MiB         self.tee("  %d ligand configurations "%len(cool0_Es_MM) + \
  1061                                            "were randomly docked into the binding site using "+ \
  1062                                            "%d translations and %d rotations "%(n_trans_n,self._n_rot) + \
  1063  236.492 MiB    0.000 MiB                  "in " + HMStime(time.time()-dock_start_time))
  1064  236.492 MiB    0.000 MiB         self.tee("  the predicted free energy difference between the" + \
  1065  236.492 MiB    0.000 MiB                  " first and second docking states is " + \
  1066  236.492 MiB    0.000 MiB                  "%f (%f)"%(f_grid0.mean(),f_grid0_std))
  1067                             
  1068  236.492 MiB    0.000 MiB         ravel_start_time = time.time()
  1069  236.492 MiB    0.000 MiB         for term in E.keys():
  1070  236.492 MiB    0.000 MiB           E[term] = np.ravel(E[term][:,:self._n_rot,:self._n_trans])
  1071  236.492 MiB    0.000 MiB         self.tee("  raveled energy terms in " + \
  1072  236.492 MiB    0.000 MiB           HMStime(time.time()-ravel_start_time))
  1073                             
  1074                             #      idock.close()
  1075                             
  1076  236.492 MiB    0.000 MiB         stats_start_time = time.time()
  1077  236.492 MiB    0.000 MiB         if self.params['dock']['do_calc_random_dock_stats']:
  1078                                     self.calc_random_dock_stats(E)
  1079                                     self.tee("  calculated random dock stats in " + \
  1080                                       HMStime(time.time()-stats_start_time))
  1081                             
  1082  237.445 MiB    0.953 MiB         self._save_progress('dock')
  1083  237.445 MiB    0.000 MiB         if randomOnly:
  1084                                     self._clear_lock('dock')
  1085                                     return
  1086                                 else:
  1087                                   # Continuing from a previous docking instance
  1088                                   self.tee("\n>>> Initial docking, continued")
  1089                                   lambda_o = self.dock_protocol[-1]
  1090                                   confs = self.confs['dock']['samples'][-1][0]
  1091                                   E = self.dock_Es[-1][0]
  1092                             
  1093                                 # Main loop for initial docking:
  1094                                 # choose new thermodynamic variables,
  1095                                 # randomly select seeds,
  1096                                 # simulate
  1097  237.445 MiB    0.000 MiB       rejectStage = 0
  1098  239.688 MiB    2.242 MiB       while (not self.dock_protocol[-1]['crossed']):
  1099                                   # Determine next value of the protocol
  1100  239.688 MiB    0.000 MiB         lambda_n = self._next_dock_state(E = E, lambda_o = lambda_o, \
  1101  239.688 MiB    0.000 MiB             pow = rejectStage)
  1102  239.688 MiB    0.000 MiB         self.dock_protocol.append(lambda_n)
  1103  239.688 MiB    0.000 MiB         if len(self.dock_protocol)>100:
  1104                                     raise Exception('Too many replicas!')
  1105                             
  1106                                   # Randomly select seeds for new trajectory
  1107  239.688 MiB    0.000 MiB         u_o = self._u_kln([E],[lambda_o])
  1108  239.688 MiB    0.000 MiB         u_n = self._u_kln([E],[lambda_n])
  1109  239.688 MiB    0.000 MiB         w = np.exp(u_o-u_n)
  1110  239.688 MiB    0.000 MiB         seedIndicies = np.random.choice(len(u_o), \
  1111  239.688 MiB    0.000 MiB           size = self.params['dock']['seeds_per_state'], \
  1112  239.688 MiB    0.000 MiB           p=w/sum(w))
  1113                             
  1114  239.688 MiB    0.000 MiB         if len(self.dock_protocol)==2: # Cooling state 0 configurations, randomly oriented
  1115                                     # Use the lowest energy configuration in the first docking state for replica exchange
  1116  237.684 MiB   -2.004 MiB           ind = np.argmin(u_n)
  1117  237.688 MiB    0.004 MiB           (c,i_rot,i_trans) = np.unravel_index(ind, (self.params['dock']['seeds_per_state'], self._n_rot, self._n_trans))
  1118  237.691 MiB    0.004 MiB           repX_conf = np.add(np.dot(cool0_confs[c], self._random_rotT[i_rot,:,:]),\
  1119  237.691 MiB    0.000 MiB                              self._random_trans[i_trans].array)
  1120  237.691 MiB    0.000 MiB           self.confs['dock']['replicas'] = [repX_conf]
  1121  237.691 MiB    0.000 MiB           self.confs['dock']['samples'] = [[repX_conf]]
  1122  237.691 MiB    0.000 MiB           self.dock_Es = [[dict([(key,np.array([val[ind]])) for (key,val) in E.iteritems()])]]
  1123  237.691 MiB    0.000 MiB           seeds = []
  1124  237.730 MiB    0.039 MiB           for ind in seedIndicies:
  1125  237.730 MiB    0.000 MiB             (c,i_rot,i_trans) = np.unravel_index(ind, (self.params['dock']['seeds_per_state'], self._n_rot, self._n_trans))
  1126  237.730 MiB    0.000 MiB             seeds.append(np.add(np.dot(cool0_confs[c], self._random_rotT[i_rot,:,:]), self._random_trans[i_trans].array))
  1127  237.730 MiB    0.000 MiB           confs = None
  1128  237.730 MiB    0.000 MiB           E = {}
  1129                                   else: # Seeds from last state
  1130  239.688 MiB    1.957 MiB           seeds = [confs[ind] for ind in seedIndicies]
  1131  239.688 MiB    0.000 MiB         self.confs['dock']['seeds'] = seeds
  1132                             
  1133                                   # Store old data
  1134  239.688 MiB    0.000 MiB         confs_o = confs
  1135  239.688 MiB    0.000 MiB         E_o = E
  1136                             
  1137                                   # Simulate
  1138  239.688 MiB    0.000 MiB         sim_start_time = time.time()
  1139  239.688 MiB    0.000 MiB         self._set_universe_force_field(lambda_n)
  1140  239.688 MiB    0.000 MiB         (confs, Es_tot, tau_ac) = self._initial_sim_state('dock', seeds, \
  1141  239.688 MiB    0.000 MiB           normalize=False, doMC=True)
  1142                                   
  1143                                   # Store data
  1144  239.688 MiB    0.000 MiB         self.dock_protocol[-1]['delta_t'] = self.delta_t
  1145  239.688 MiB    0.000 MiB         self.dock_protocol[-1]['tau_ac'] = tau_ac
  1146                             
  1147  239.688 MiB    0.000 MiB         self.tee("  generated %d configurations "%len(confs) + \
  1148                                            "(tau_ac=%f, "%self.dock_protocol[-1]['tau_ac'] + \
  1149                                            "dt=%f ps) "%self.dock_protocol[-1]['delta_t'] + \
  1150                                            "with progress %f "%self.dock_protocol[-1]['a'] + \
  1151  239.688 MiB    0.000 MiB                  "in " + HMStime(time.time()-sim_start_time))
  1152                             
  1153                                   # Get state energies
  1154  239.688 MiB    0.000 MiB         E = self._calc_E(confs)
  1155                             
  1156  239.688 MiB    0.000 MiB         if len(self.dock_protocol)>2:
  1157                                     # Estimate the mean replica exchange acceptance rate
  1158                                     # between the previous and new state
  1159  239.688 MiB    0.000 MiB           (u_kln,N_k) = self._u_kln([[E_o],[E]], self.dock_protocol[-2:])
  1160  239.688 MiB    0.000 MiB           N = min(N_k)
  1161  239.688 MiB    0.000 MiB           acc = np.exp(-u_kln[0,1,:N]-u_kln[1,0,:N]+u_kln[0,0,:N]+u_kln[1,1,:N])
  1162  239.688 MiB    0.000 MiB           mean_acc = np.mean(np.minimum(acc,np.ones(acc.shape)))
  1163                                     
  1164  239.688 MiB    0.000 MiB           if (mean_acc<self.params['dock']['min_repX_acc']):
  1165                                       # If the acceptance probability is too low,
  1166                                       # reject the state and restart
  1167                                       self.dock_protocol.pop()
  1168                                       confs = confs_o
  1169                                       E = E_o
  1170                                       rejectStage += 1
  1171                                       self.tee("  rejected new state, as estimated replica exchange acceptance rate of %f is too low"%mean_acc)
  1172  239.688 MiB    0.000 MiB           elif (mean_acc>0.95) and (not lambda_n['crossed']):
  1173                                       # If the acceptance probability is too high,
  1174                                       # reject the previous state and restart
  1175                                       self.confs['dock']['replicas'][-1] = confs[np.argmin(Es_tot)]
  1176                                       self.dock_protocol.pop()
  1177                                       self.dock_protocol[-1] = lambda_n
  1178                                       self.dock_protocol[-1]['delta_t'] = self.delta_t
  1179                                       rejectStage = 0
  1180                                       lambda_o = lambda_n
  1181                                       self.tee("  rejected previous state, as estimated replica exchange acceptance rate of %f is too high"%mean_acc)
  1182                                     else:
  1183                                       # Store data and continue with initialization
  1184  239.688 MiB    0.000 MiB             self.confs['dock']['replicas'].append(confs[np.argmin(Es_tot)])
  1185  239.688 MiB    0.000 MiB             self.confs['dock']['samples'].append([confs])
  1186  239.688 MiB    0.000 MiB             if (not self.params['dock']['keep_intermediate']):
  1187  239.688 MiB    0.000 MiB               self.confs['dock']['samples'][-2] = []
  1188  239.688 MiB    0.000 MiB             self.dock_Es.append([E])
  1189  239.688 MiB    0.000 MiB             self.dock_protocol[-1]['delta_t'] = self.delta_t
  1190  239.688 MiB    0.000 MiB             rejectStage = 0
  1191  239.688 MiB    0.000 MiB             lambda_o = lambda_n
  1192  239.688 MiB    0.000 MiB             self.tee("  the estimated replica exchange acceptance rate is %f"%mean_acc)
  1193                                   else:
  1194                                     # Store data and continue with initialization (first time)
  1195  238.602 MiB   -1.086 MiB           self.confs['dock']['replicas'].append(confs[np.argmin(Es_tot)])
  1196  238.602 MiB    0.000 MiB           self.confs['dock']['samples'].append([confs])
  1197  238.602 MiB    0.000 MiB           self.dock_Es.append([E])
  1198  238.602 MiB    0.000 MiB           self.dock_protocol[-1]['delta_t'] = self.delta_t
  1199  238.602 MiB    0.000 MiB           rejectStage = 0
  1200  238.602 MiB    0.000 MiB           lambda_o = lambda_n
  1201                                   
  1202  239.688 MiB    1.086 MiB         self._save_progress('dock')
  1203  239.688 MiB    0.000 MiB         self.tee("")
  1204                             
  1205  239.688 MiB    0.000 MiB       K = len(self.dock_protocol)
  1206  239.688 MiB    0.000 MiB       self.tee("  %d states in the docking process sampled in %s"%(K,\
  1207  239.688 MiB    0.000 MiB         HMStime(time.time()-dock_start_time)))
  1208                                   
  1209  239.688 MiB    0.000 MiB       self._dock_cycle += 1
  1210  239.688 MiB    0.000 MiB       self._dock_total_cycle += 1
  1211  239.688 MiB    0.000 MiB       self._save_progress('dock')
  1212  239.688 MiB    0.000 MiB       self.tee("\nElapsed time for initial docking: " + \
  1213  239.688 MiB    0.000 MiB         HMStime(time.time()-dock_start_time))
  1214  239.688 MiB    0.000 MiB       self._clear_lock('dock')


